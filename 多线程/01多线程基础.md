## 1 线程创建

### 1.1 Runnable和Thread区别

- 接口更适合多个相同的程序代码的线程去共享同一个资源；
- 接口可以避免单继承的局限性；
- 线程池只能放入实现Runnable接口或Callable接口的线程，不能直接放入继承Thread的类。

> 在Java中，每次程序启动都至少会启动两个线程。一个时main线程，一个是垃圾收集线程。

### 1.2 Runnable和Callable接口

- 相同点
  - 都是接口；
  - 都需要调用Thread.start()来启动线程；
- 不同点
  - Callable可以返回执行结果，Runnable不可以；
  - Callable的call()方法可以抛出异常，Runnable的run()方法不允许有异常；
  - 实现Callable接口的线程可以调用FutureTask.cancle()取消执行，而实现Runnable接口的线程不能。

> Callable接口支持返回结果，但是需要调用FutureTask.get()方法来获取，此方法会阻塞主线程直到结果获取到；当不调用此方法时，主线程不会阻塞。

## 2 线程生命周期

### 2.1 新建

new关键词创建了一个线程之后，该线程就处于新建状态

JVM为线程分配内存，初始化成员变量值

### 2.2 就绪

当线程对象调用了start()方法之后，该线程就处于就绪状态

JVM为线程创建方法栈和程序计数器，等待线程调度器调度

### 2.3 运行

就绪状态的线程获取CPU资源，开始运行资源，开始运行run()方法，该线程进入运行状态

### 2.4 阻塞

当发生如下情况时，线程将会进入阻塞状态：

- 线程调用sleep()方法主动放弃所占用的处理器资源；
- 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；
- 线程试图获得了一个同步锁（同步监视器），但是该同步锁正被其他线程所持有；
- 线程在等待某个通知（notify）；
- 程序调用了线程的suspend()方法将该线程挂起，但是这个方法容易导致死锁，所以应该避免使用该防范

### 2.5 死亡

线程会以如下方式结束：

- run()或者call()方法执行完成，线程正常结束；
- 线程抛出一个为捕获的Exception或者Error；
- 调用stop()方法结束掉该线程，该方法容易导致死锁，不推荐使用。

## 3 线程安全

如果有多个线程同时运行同一个实现了Runnable接口的类，程序每次运行结果和单线程运行结果时一样的，而且其他的变量值也和预期时一样的，就是线程安全的；反之就是线程不安全。

### 3.1 同步锁

```java
public class Ticket implements Runnable {
    private int ticketNum = 100;

    Lock lock = new ReentrantLock(true);

    @Override
    public void run() {
        while (true) {
            lock.lock();
            try {
                if (ticketNum > 0) {
                    Thread.sleep(100);
                    System.out.println(Thread.currentThread().getName() + " 线程销售了电影票：" + ticketNum--);
                }
            } catch (InterruptedException e) {
                                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
}
```

## 4 线程死锁

### 4.1 定义

​	多线程以及进程改善了系统资源的利用率并提高了系统的处理能力，然而并发执行也带来了新的问题：死锁

​	死锁是指多个线程因为竞争资源而造成的一种僵局（互相等待），若无外力作用，这些线程都将无法向前推进。



```java
public class Ticket implements Runnable {
    private int ticketNum = 100;

    Lock lock = new ReentrantLock(true);

    @Override
    public void run() {
        while (true) {
            lock.lock();
            try {
                if (ticketNum > 0) {
                    Thread.sleep(100);
                    System.out.println(Thread.currentThread().getName() + " 线程销售了电影票：" + ticketNum--);
                }
            } catch (InterruptedException e) {
                                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
}
```

### 4.1 死锁产生的必要条件

- 互斥条件

  线程要求对锁分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程锁占有。此时若其他线程请求该资源，那么只能等待。

- 不可剥夺条件

  线程所获得的资源在未使用完毕之前，不能被其他线程强行夺走，即只能由获得该资源的线程自己来释放。

- 请求与保持条件

  线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其他线程占有，此时请求线程被阻塞，但对自己已获得的资源保持不变。

- 循环等待条件

  

### 4.2 死锁处理

- 预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个条件，来防治死锁的产生；
- 避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生；
- 检测死锁：允许系统在运行过程中发生死锁，但可设置监测机制及时检测死锁的发生，并采取适当的措施加以清除；
- 解除死锁：当检测出死锁之后，便采取适当措施将线程从死锁状态中解脱出来。

#### 4.2.1 死锁预防

预防死锁就是想办法至少破坏死锁的四个必要条件之一，防止死锁的出现。

- 破坏互斥条件

  互斥条件是无法破坏的。因此预防死锁住要时破坏其他几个条件，而不去设计破坏互斥条件。

- 破坏“占有并等待条件”

  - 一次性分配资源：创建线程时，要求把该线程所有的资源一次性加载。适用于提前预知线程所需要的所有资源的情况；
  - 提前释放资源：线程在申请新资源时，需要提前释放已占用资源。

-  破坏“不可抢占”条件

  - 如果占有某些资源的一个线程进行进一步资源请求被拒绝，则该线程必须释放他已经占用的资源，如果有必要，可以再次申请这些资源和另外的资源。
  - 如果一个线程请求当前被另一个线程占用的资源，则操作系统可以抢占另一个线程，要求它必须释放掉资源。

- 破坏“循环等待”条件

  将系统中的所有资源统一编号，线程可以在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序提出。这样就能保证系统不出现死锁。

## 5 线程通信

### 5.1 线程通讯方式

- Object的 wait \ notify \ notifyAll

  Condition的 await \ signal \ sinalAll

- CountDownLatch: 用于某个线程A等待若干个其他线程执行完毕之后，他才执行

- CyclicBarrier：一组线程等待至某个状态之后再全部同时执行

- Semaphore：用于控制对某组资源的访问权限

#### 5.1.1 休眠唤醒

- wait()和notify()

  ```java
  public class WaitNotifyDemo {
  
      private int i = 0;
      private Object obj = new Object();
  
      public void odd() {
          while (i < 10) {
              synchronized (obj) {
                  if (i % 2 == 1) {
                      System.out.println("奇数" + i++);
                      obj.notify();
                  } else {
                      try {
                          obj.wait();
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                  }
              }
          }
      }
  
      public void Even() {
          while (i < 10) {
              synchronized (obj){
                  if (i % 2 == 0) {
                      System.out.println("偶数" + i++);
                      obj.notify();
                  } else {
                      try {
                          obj.wait();
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                  }
              }
          }
      }
  
      public static void main(String[] args) {
          WaitNotifyDemo demo = new WaitNotifyDemo();
          new Thread(() -> demo.odd()).start();
  
          new Thread(() -> demo.Even()).start();
      }
  }
  ```

- await()和signal()

  ```java
  public class AwaitSignalDemo {
  
      private int i = 0;
      private Lock lock = new ReentrantLock(false);
      private Condition condition = lock.newCondition();
  
      public void odd() throws InterruptedException {
          while (i < 10) {
              lock.lock();
              try {
                  if (i % 2 == 1) {
                      System.out.println("奇数" + i++);
                      condition.signal();
                  } else {
                      condition.await();
                  }
              } finally {
                  lock.unlock();
              }
          }
      }
  
      public void even() throws InterruptedException {
          while (i < 10) {
              lock.lock();
              try {
                  if (i % 2 == 0) {
                      System.out.println("偶数" + i++);
                      condition.signal();
                  } else {
                      condition.await();
                  }
              } finally {
                  lock.unlock();
              }
          }
      }
  
      public static void main(String[] args) {
          final AwaitSignalDemo demo = new AwaitSignalDemo();
  
          new Thread(() -> {
              try {
                  demo.odd();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }).start();
  
          new Thread(() -> {
              try {
                  demo.even();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }).start();
      }
  }
  ```

  