## 1 线程创建

### 1.1 Runnable和Thread区别

- 接口更适合多个相同的程序代码的线程去共享同一个资源；
- 接口可以避免单继承的局限性；
- 线程池只能放入实现Runnable接口或Callable接口的线程，不能直接放入继承Thread的类。

> 在Java中，每次程序启动都至少会启动两个线程。一个时main线程，一个是垃圾收集线程。

### 1.2 Runnable和Callable接口

- 相同点
  - 都是接口；
  - 都需要调用Thread.start()来启动线程；
- 不同点
  - Callable可以返回执行结果，Runnable不可以；
  - Callable的call()方法可以抛出异常，Runnable的run()方法不允许有异常；
  - 实现Callable接口的线程可以调用FutureTask.cancle()取消执行，而实现Runnable接口的线程不能。

> Callable接口支持返回结果，但是需要调用FutureTask.get()方法来获取，此方法会阻塞主线程直到结果获取到；当不调用此方法时，主线程不会阻塞。

## 2 线程生命周期

### 2.1 新建

new关键词创建了一个线程之后，该线程就处于新建状态

JVM为线程分配内存，初始化成员变量值

### 2.2 就绪

当线程对象调用了start()方法之后，该线程就处于就绪状态

JVM为线程创建方法栈和程序计数器，等待线程调度器调度

### 2.3 运行

就绪状态的线程获取CPU资源，开始运行资源，开始运行run()方法，该线程进入运行状态

### 2.4 阻塞

当发生如下情况时，线程将会进入阻塞状态：

- 线程调用sleep()方法主动放弃所占用的处理器资源；
- 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；
- 线程试图获得了一个同步锁（同步监视器），但是该同步锁正被其他线程所持有；
- 线程在等待某个通知（notify）；
- 程序调用了线程的suspend()方法将该线程挂起，但是这个方法容易导致死锁，所以应该避免使用该防范

### 2.5 死亡

线程会以如下方式结束：

- run()或者call()方法执行完成，线程正常结束；
- 线程抛出一个为捕获的Exception或者Error；
- 调用stop()方法结束掉该线程，该方法容易导致死锁，不推荐使用。

## 3 线程安全

如果有多个线程同时运行同一个实现了Runnable接口的类，程序每次运行结果和单线程运行结果时一样的，而且其他的变量值也和预期时一样的，就是线程安全的；反之就是线程不安全。

### 3.1 同步锁

```java
public class Ticket implements Runnable {
    private int ticketNum = 100;

    Lock lock = new ReentrantLock(true);

    @Override
    public void run() {
        while (true) {
            lock.lock();
            try {
                if (ticketNum > 0) {
                    Thread.sleep(100);
                    System.out.println(Thread.currentThread().getName() + " 线程销售了电影票：" + ticketNum--);
                }
            } catch (InterruptedException e) {
                                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
}
```

## 4 线程死锁

### 4.1 定义

​	多线程以及进程改善了系统资源的利用率并提高了系统的处理能力，然而并发执行也带来了新的问题：死锁

​	死锁是指多个线程因为竞争资源而造成的一种僵局（互相等待），若无外力作用，这些线程都将无法向前推进。



```-
public class Ticket implements Runnable {
    private int ticketNum = 100;

    Lock lock = new ReentrantLock(true);

    @Override
    public void run() {
        while (true) {
            lock.lock();
            try {
                if (ticketNum > 0) {
                    Thread.sleep(100);
                    System.out.println(Thread.currentThread().getName() + " 线程销售了电影票：" + ticketNum--);
                }
            } catch (InterruptedException e) {
                                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
}
```