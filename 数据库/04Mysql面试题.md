- ## 事务四大特性

  - 原子性
    不可分割的操作单元，事务中的所有操作、要么全部成功、要么全部失败
  - 一致性
    如果在执行事务之前的数据库是一致的，那么在执行事务之后的数据库还是一致的。
    比如A账户有100元、B账户也有100元，A转账100给B。其他事物看到的要么是A100、B100，要么是A0、B200，A减少了B还没增加的中间状态对其他事务是不可见的。
  - 隔离性
    事务操作之间彼此独立和透明互不影响，事务独立运行。
    这通常使用锁来实现，一个事务处理后的结果，影响了其他事物，那么其他事物会撤回。事物100%隔离，这需要牺牲一些速度。
  - 持久性
    事物一旦提交，其结果就是永久的，即便发生系统故障，也能恢复。

  ## 脏读、幻读、不可重复读

  - 脏读
    事务1将某一值修改，还未提交，事务2读到修改后未提交的值，此时事务1因为某些原因回滚了，导致事务2读取到的数据是无效的。
  - 不可重复读
    在整个事务过程中，每次读取同一条数据的结果都是不一样的。如果事务1在事务2的更新操作之前读取一条数据，在事务2的更新操作之后读取一次数据，那么两次读取的结果是不一样的。针对的是其他事物的update和delete
  - 幻读
    在同一事物之中查询多次数据库，每次查询的结果集数量都是不一样的。针对的是其他事物的insert

  ## 事物的隔离级别

  - 未提交读<Read Uncommitted>
    允许脏读，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。也就是可能读取到其他事务未提交但是已修改后的数据。
  - 提交读<Read Committed>
    只能读取到已经提交的数据。Oracle数据库采用的是提交读级别。
  - 可重复读<Repeated Read>
    无论其他事务是否修改并提交了数据，在本事务结束之前，读取到的数据值始终不受其他事务影响。
  - 串行读<Serializable>
    完全串行化的读，每次读都需要获取表级共享锁，读写互相都会阻塞。

  > **MySQL的InnoDB引擎默认使用可重复读**

  ## 索引相关

  **数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树，B树索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反它会从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。**

  - InnoDB
    使用B+树作为索引结构，但是InnoDB的数据文件本身就是索引文件，叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这种索引叫做“聚焦索引”。InnoDB的辅助索引的data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。InnoDB的索引实现后，不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。在Innodb中也不建议使用非单调的字段作为主键，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，建议使用自增字段作为主键。

  - 四类索引

    - index
      普通索引，数据可以重复，没有限制
    - unique
      唯一索引，要求索引列的值必须唯一，但允许有空值；如果是组合索引、那么列值的组合必须唯一
    - primary key
      主键索引，是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。
      组合索引，在多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。
    - fulltext
      全文索引，是对于大表的文本域：char/varchar/text列才能创建全文索引，主要用于查找文本中的关键字，并不是与索引中的值进行比较。fulltext更像是一个搜索引擎，配合match against操作使用，而不是一般的where语句加like。

    > 全文索引目前只有MyISAM存储引擎支持全文索引，InnoDB引擎5.6以下版本还不支持全文索引

  ## 数据库三范式

  - 确保每列都保持原子性
  - 确保表中每列都和主键相关
  - 确保每列都和主键列直接相关，而不能间接相关

  ## Myisam和InnoDB的区别

  - InnoDB支持事务，MyISAM不支持。
  - MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用。
  - InnoDB支持外键，MyISAM不支持。
  - 从MySQL5.5.5以后，InnoDB是默认引擎。
  - MyISAM支持全文类型索引，而InnoDB不支持全文索引。
  - InnoDB中不保存表的总行数，select count(*) from table时，InnoDB需要扫描整个表计算有多少行，但MyISAM只需简单读出保存好的总行数即可。注：当count(*)语句包含where条件时MyISAM也需扫描整个表。
  - 对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。
  - 清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。MyisAM使用delete语句删除后并不会立刻清理磁盘空间，需要定时清理，命令：OPTIMIZE table dept;
  - InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’）
  - Myisam创建表生成三个文件：.frm 数据表结构 、 .myd 数据文件 、 .myi 索引文件，Innodb只生成一个 .frm文件，数据存放在ibdata1.log
  - 现在一般都选用InnoDB，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。
  - 应用场景：
    - MyISAM不支持事务处理等高级功能，但它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
    - InnoDB用于需要事务处理的应用程序，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。