## 1 jvm内存结构

> 线程共享：方法区、堆

> 线程私有：本地方法栈、虚拟机栈、程序计数器

### 1.1 程序计数器

​	**程序计数器**是一块较小的内存，它可以看作是当前线程所执行的字节码的行号指示器。

​	如果正在执行的是普通java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，那么这个计数器的值为空。此区域是唯一一个在《java虚拟机规范》中没有规定OOM情况的区域。

### 1.2 java虚拟机栈

​	与程序计数器一样，**Java虚拟机栈**（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

​	如果线程请求的java虚拟机栈深度超过了虚拟机所允许的深度，将抛出StackOverFlow异常；如果java虚拟机栈容量可以动态扩容，当栈容量扩展时无法申请到足够的内存时则会抛出OutOfMemoryError异常。

### 1.3 本地方法栈

​	**本地方法栈**（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。

​	如果线程请求的本地方法栈深度超过虚拟机所允许的最大深度，将抛出StackOverFlowError；如果本地方法栈的容量可以动态扩容，那么在本地方法栈无法请求到足够的内存时则会抛出OutOfMemoryError。

### 1.4 Java堆 Heap

​	**java堆**是java内存区域中最大的一块，所有的对象都在java堆中分配，线程共享，在虚拟机启动时创建。

​	如果在java堆中没有完成实例分配，并且堆也无法再扩展时，JAVA虚拟机将抛出OutOfMemoryError异常。

### 1.5 方法区

​	**方法区**与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

​	方法区如果无法申请到足够的内存时，将抛出OutOfMemoryError异常。

#### 1.5.1 运行时常量池

​	**运行时常量池**是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项信息是常量池表，用于存放编译期间生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

​	运行时常量池如果无法申请到足够的内存时，将抛出OutOfMemoryError异常。

## 2 如何判断一个对象是否存活

### 2.1引用计数法

​	所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.
​	引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。

### 2.2 可达性分析算法

​	该算法的思想是：从一个被称为**GC Roots**的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。
在java中可以作为GC Roots的对象有以下几种:

- 虚拟机栈中引用的对象
- 方法区类静态属性引用的对象
- 方法区常量池引用的对象
- 本地方法栈JNI引用的对象

​	<span style="color:#40B8FA">虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比**不一定会被回收**。当一个对象不可达GC Root时，这个对象并 **不会立马被回收**，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记</span>

​	<span style="color:#40B8FA">如果对象在可达性分析中没有与GC Root的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。</span>

​	<span style="color:#40B8FA">如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的对队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。</span>

## 3 java中垃圾收集方法

### 3.1 标记-清除

​	这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：

- 效率不高，标记和清除的效率都很低；
- 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。

### 3.2 复制算法

​	为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清除完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一半的内存。

​	于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)

### 3.3 标记-整理算法

​	该算法主要是为了解决标记-清除算法产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。

### 3.4 分代收集

​	现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用**复制**算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用**标记-整理** 或者 **标记-清除**。

## <span style="color:red">4 java内存模型</span>

​	java内存模型(JMM)是线程间通信的控制机制.JMM定义了主内存和线程之间抽象关系。线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。

## 5 类加载过程

> java类加载需要经历一下7个过程：

​	简单来讲，首先**判断在常量池中是否能定位到类的符号引用**，并且检查这个符号引用代表的类是否已被加载、解析初始化过。如果没有、则执行类加载和初始化过程，具体可分为加载、验证、准备、解析、初始化过程；如果有则直接创建对象，具体可分为实例对象分配内存、赋值、执行实例初始化代码、返回引用等。

### 5.1 校验

​	**判断常量池是否能定位类的符号引用**，并且检查这个符号引用代表的类是否被加载、解析、初始化过。如果没有则执行第一步，如果有则执行第二步。

### 5.2 类加载和初始化

- 加载

  <span style="color:LimeGreen">**类加载器**</span>根据<span style="color:LimeGreen">**类的全限命名**</span>来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例

- 验证

  <span style="color:LimeGreen">**格式验证**</span>：验证是否符合class文件规范，比如必须以魔数0xCAFEBABE开头

  **<span style="color:LimeGreen">语义验证</span>**：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）

  **<span style="color:LimeGreen">操作验证</span>**：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）

- 准备

  ​	为类中的所有静态变量/常量**分配内存空间**，并为其设置一个**初始值**（由于还没有产生对象，实例变量不在此操作范围内）

  ```java
  public static int value= 1; // 初始化后的值为 0
  
  public static final int value= 1; // 初始化后的值为 1
  ```

- 解析

  将常量池中的**符号引用转为直接引用**（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法）

  - 符号引用：比如我们规定了json字符串，"{}"表示对象，"[]"表示数组，"{}"和"[]"就相当于符号引用。在JVM中符号引用是用**一组符号**描述**所引用的目标**，比如用**0x4000**声明这是一个枚举类型
  - 直接引用：内存地址（指针/偏移量/句柄）

- 初始化

  执行类构造器 **init 方法**，init方法包含 为静态变量赋值、执行static代码块

### 5.3 创建对象

- 在堆内存为实例对象分配内存

  为实例变量**分配内存**（包括本类和父类），但不包括任何静态变量

- 对实例变量赋默认值

  将方法区内对实例变量的定义拷贝一份到堆区，然后**赋默认值**

- 执行实例初始化代码

  先**初始化父类再初始化子类**，初始化时先执行非静态代码块（包括非静态初始化块，非静态属性）再执行构造方法

  非静态代码块也叫做实例代码块

- 将堆区对象的地址赋值给栈区的引用变量

  有类似于Child c = new Child()形式的引用，将堆区对象的地址赋值给栈区的**引用变量c**

## 6 类加载机制

​	虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。

## 7 类加载器双亲委派机制

​	当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

## 8 类加载器有哪些

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。
主要有一下四种类加载器:

1. 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
2. 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
4. 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。

## 9 java内存分配与回收策略以及Minor GC和Major GC

- 对象优先在堆的Eden区分配。

- 大对象直接进入老年代.

- 长期存活的对象将直接进入老年代.
  当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。

## <span style="color:red"> 对象分配规则</span>

- 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
- 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
- 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
- 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
- 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。

##  解释内存中的栈、堆、静态区的用法

​	通常我们定义一个基本数据类型的变量，一个对象的引用，都使用java虚拟机栈空间；而通过new关键字创建的对象则放在java对空间；程序中的字面量如书写的100、“hello”和常量都放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是存放在堆空间。

```java
/**
 * str变量名存放在栈空间
 * new出来的String对象存放在堆内存中
 * 字面量hello存放在字符串常量池中
 */
String str = new String("hello");
```

##  Perm Space

​	Perm Space中保存的是什么数据？会引起OutOfMemoryError异常吗？

​	Perm Space中保存的是加载的class文件。

​	会引起OutOfMemory，出现异常可以设置 -XX:PermSize 的大小。JDK 1.8后，字符串常量不存放在永久带，而是在堆内存中，JDK8以后没有永久代概念，而是用元空间替代，元空间不存在虚拟机中，二是使用本地内存。

##  什么是类的加载

​	类的加载指的是将累的 .class 文件中的二进制数据读取到内存中，将其放在运行时数据库的方法区内，然后在堆区域创建一个 java.lang.Class 对象，用来封装在方法区内的数据结构。