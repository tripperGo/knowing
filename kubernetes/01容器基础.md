## 1 容器是一种进程

> 对于大多数的linux容器来说，Cgroups是用来制造约束的主要手段，而Namespace则是用来修改进程视图的主要方法。

​	容器其实是一种沙盒技术。沙盒就是能够像一个集装箱一样，把我们的应用“装”起来的技术。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬来搬去。

```java
$ docker run -it busybox /bin/sh

// 在容器中执行
$ ps
PID USER TIME COMMAND 
1 	root 0:00 /bin/sh 
10 	root 0:00 ps
```

​	在Docker容器中最开始执行的/bin/sh，就是这个容器的PID=1的进程，而这个容器里一共有两个进程在运行。这意味着我们前边执行的/bin/sh和ps，已经被Docker隔离在了一个跟宿主机完全不同的世界当中。

​	Docker容器是一种特殊的进程，在创建容器进程时，指定了这个进程需要启动的一组NameSpace参数。这样，容器就只能看到当前NameSpace所限定的资源、文件、设备、状态等。而对于宿主机以及其他不相关的程序，他就完全看不到了。

- 虚拟机和Docker容器的比较

![](https://static001.geekbang.org/resource/image/d1/96/d1bb34cda8744514ba4c233435bf4e96.jpg)

- 虚拟机

  ​	其中，名为 Hypervisor 的软件是虚拟机最主要的部分。它通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，比如 CPU、内存、I/O 设备等等。然后，它在这些虚拟的硬件上安装了一个新的操作系统，即 Guest OS。

  ​	这样，用户的应用进程就可以运行在这个虚拟的机器中，它能看到的自然也只有 Guest OS 的文件和目录，以及这个机器里的虚拟设备。这就是为什么虚拟机也能起到将不同的应用进程相互隔离的作用。

- docker容器

  ​	docker容器用一个名为 Docker Engine 的软件替换了 Hypervisor。这也是为什么，很多人会把 Docker 项目称为“轻量级”虚拟化技术的原因，实际上就是把虚拟机的概念套在了容器上。

  ​	实际上Docker容器跟真实存在的虚拟机不同，在使用Docker的时候，并没有一个真正的“Docker 容器”运行在宿主机里面。Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时，Docker 为它们加上了各种各样的 Namespace 参数。

  ​	这时，这些进程就会觉得自己是各自 PID Namespace 里的第 1 号进程，只能看到各自 Mount Namespace 里挂载的目录和文件，只能访问到各自 Network Namespace 里的网络设备，就仿佛运行在一个个“容器”里面，与世隔绝。

## 2 CGroups

> **CGroups**的主要作用是限制一个进程组能够使用的资源上限，包括CPU、内存、磁盘、网络带宽等等。

