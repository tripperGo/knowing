## 1 redis持久化机制

​	Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。

​	实现：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。

​	RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）

​	AOF：Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。
当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。

## 2 缓存概念理解

### 2.1 缓存雪崩

​	**概念：**当大量的缓存设置了相同的过期时间，在同一时刻这些缓存都过期了，原本所有应该访问缓存的请求全部都去查询数据库了，对数据库造成巨大的压力，严重的会造成数据库宕机。从而形成一系列的连锁反应，造成整个系统的崩溃。

​	**解决方案：**很多人都考虑用加锁或者队列的方式保证不会有大量的线程对数据库同时进行读写，还有一个简单的方法就是将缓存失效时间分散开。

### 2.2 缓存穿透

​	**缓存穿透**就是指用户查询的数据，在数据库中没有，在缓存中自然也不存在。这样就导致了用户每次查询数据的时候，在缓存中查询不到，每次都去数据库再查询一次，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查询数据库，也就是缓存命中率问题。

​	**解决方案**:

​	**<span style="color:red">布隆过滤器：</span>**将所有可能存在的数据放到一个足够大的bitmap中，一个一定不会存在的数据一定会被bitmap拦截到，从而避免了对底层存储系统的查询压力。

​	**<span style="color:red">设置空值缓存：</span>**如果查询结果为空，那么仍然将这个空值进行缓存，但是这个缓存的过期时间不超过5分钟。这样第二次请求就能在缓存中取到值了，不会继续访问数据库。

### 2.3 缓存预热

​	**缓存预热**就是系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免用户在第一次请求的时候先查询数据库再将数据缓存的问题。用户直接查询被预热的缓存数据。

### 2.4 缓存降级

​	当访问量剧增、服务出现问题或非核心服务影响到核心服务的性能时，仍然要保证服务是可用的，即使有损服务。可以通过系统的关键数据进行自动降级，或者通过手动配置的方式人工降级。

​	服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩。因此对于不重要的缓存数据，可以采取服务降级策略，比如：Redis出现问题，不去数据库查询，而是直接返回默认值给用户。

## 3 热点数据和冷数据

​	热点数据缓存才有意义，对于冷数据而言，大部分数据还没有再次访问就已经过期被基础内存，不仅占用资源，而且价值不大。频繁修改的数据、要视情况而选择缓存。

​	一般的，**数据更新前至少读取两次**，缓存才有意义。

​	特殊情况下，也存在修改频率很高，但是必须要缓存的数据，比如点赞数、收藏数等数据都是非常经典的热点数据，但是这些数据又不断地变化，此时应该把这些数据同步到redis缓存中，减少数据库的请求压力。

## 4 redis为什么这么快

- redis是纯内存操作
- 单线程操作，避免了线程切换的消耗
- 采用了非阻塞I/O多路复用机制

## 5 Memcache和Redis的区别

- Memcache把数据都存放在内存中，断电后就会挂掉，数据不能超过内存大小。redis可以持久化数据，断电重启后可以恢复
- memcache所有值都是简单的字符串类型，redis支持更为丰富的数据类型，提供string、list、set、zset、hash等数据结构

