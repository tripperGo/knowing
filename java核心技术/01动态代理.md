## 代理模式

给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。

代理模式角色分为 3 种：

**Subject（抽象主题角色）**：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；

**RealSubject（真实主题角色**）：真正实现业务逻辑的类；

**Proxy（代理主题角色）**：用来代理和封装真实主题；

代理模式的结构比较简单，其核心是代理类，为了让客户端能够**一致性地对待**真实对象和代理对象，在代理模式中引入了抽象层

<img src="..\cache\img\167cff3ba753f7f8.jpg" style="zoom:80%;" />

**根据字节码的创建时机**来分类，可以分为静态代理和动态代理：

- <span style="color: red;">**所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了。**</span>
- <span style="color: red;">**而动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件。**</span>

## 静态代理

- 首先定义Subject

  ```java
  public interface IPerson {
  
      void say();
  
      void sleep();
  }
  ```

- 然后定义RealSubject类

  ```java
  public class PersonService implements IPerson {
      @Override
      public void say() {
          System.out.println("吃饭~~");
      }
  
      @Override
      public void sleep() {
          System.out.println("睡觉~~");
      }
  }
  ```

  

- 定义代理类Proxy

  ```java
  public class PersonProxy implements IPerson {
  
      private IPerson target;
  
      public PersonProxy(IPerson person) {
          this.target = person;
      }
  
      @Override
      public void say() {
          this.before();
          target.say();
          this.after();
      }
  
      @Override
      public void sleep() {
          this.before();
          target.sleep();
          this.after();
      }
  
      private void before() {
          System.out.println("增强日志，记录方法执行之前的日志。。。");
      }
  
      private void after() {
          System.out.println("增强日志，记录方法执行之后的日志。。。");
      }
  }
  ```

- 客户端测试

  ```java
  public class Client {
  
      public static void main(String[] args) {
          PersonService service = new PersonService();
          PersonProxy personProxy = new PersonProxy(service);
  
          personProxy.say();
          personProxy.sleep();
      }
  }
  ```

  输出：

  ```java
  增强日志，记录方法执行之前的日志。。。
  吃饭~~
  增强日志，记录方法执行之后的日志。。。
  增强日志，记录方法执行之前的日志。。。
  睡觉~~
  增强日志，记录方法执行之后的日志。。。
  ```

### 优点

通过静态代理、能达到功能增强的目的，而且不会入侵源代码。

### 缺点

虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。

1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：

- 只维护一个代理类，由这个代理类实现多个接口，但是这样就导致**代理类过于庞大**
- 新建多个代理类，每个目标对象对应一个代理类，但是这样会**产生过多的代理类**

2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，**不易维护**。

## 动态代理

动态代理可以让类动态的生成，基于JVM的类加载机制。

JVM类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据访问入口

### JDK动态代理

**通过实现接口实现**

定义一个LogHandler类，提供日志增强的功能

```java
public class LogHandler implements InvocationHandler {

    private Object target;

    public LogHandler(Object object) {
        this.target = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object result = method.invoke(target, args);
        after();
        return result;
    }

    private void before() {
        System.out.println("方法执行之前的日志记录：" + new Date());
    }

    private void after() {
        System.out.println("方法执行之后的日志记录：" + new Date());
    }
}
```

编写客户端，动态获取Subject类、并借助Proxy的newProxyInstance方法

```java
public class Client {

    public static void main(String[] args) {
        PersonService personService = new PersonService();
        LogHandler handler = new LogHandler(personService);

        IPerson proxy = (IPerson) Proxy.newProxyInstance(personService.getClass().getClassLoader(),
                personService.getClass().getInterfaces(),
                handler);

        proxy.say();
        proxy.sleep();
    }
}
```

执行结果：

```java
方法执行之前的日志记录：Thu Jul 02 11:02:35 CST 2020
吃饭~~
方法执行之后的日志记录：Thu Jul 02 11:02:35 CST 2020
方法执行之前的日志记录：Thu Jul 02 11:02:35 CST 2020
睡觉~~
方法执行之后的日志记录：Thu Jul 02 11:02:35 CST 2020

Process finished with exit code 0
```

动态代理主要涉及到两个类，InvocationHandler和Proxy

- InvocationHandler
  - `Object invoke(Object proxy, Method method, Object[] args)` 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用
- Proxy
  - `static InvocationHandler getInvocationHandler(Object proxy)` 用于获取指定代理对象所关联的调用处理器
  - `static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces)` 返回指定接口的代理类
  - `static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)` 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法
  - `static boolean isProxyClass(Class<?> cl)` 返回 cl 是否为一个代理类

### CGLIB动态代理

**通过继承类实现**





