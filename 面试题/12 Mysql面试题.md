## 事务四大特性

- 原子性**(Atomicity)**
  不可分割的操作单元，事务中的所有操作、要么全部成功、要么全部失败。
- 一致性**(Consistency)**
  如果在执行事务之前的数据库是一致的，那么在执行事务之后的数据库还是一致的。
  比如A账户有100元、B账户也有100元，A转账100给B。其他事物看到的要么是A100、B100，要么是A0、B200，A减少了B还没增加的中间状态对其他事务是不可见的。
- 隔离性**(Isolation)**
  事务操作之间彼此独立和透明互不影响，事务独立运行。
  这通常使用锁来实现，一个事务处理后的结果，影响了其他事物，那么其他事物会撤回。事物100%隔离，这需要牺牲一些速度。
- 持久性**(Durability)**
  事物一旦提交，其结果就是永久的，即便发生系统故障，也能恢复。

## 脏读、幻读、不可重复读

- 脏读
  事务1将某一值修改，还未提交，事务2读到修改后未提交的值，此时事务1因为某些原因回滚了，导致事务2读取到的数据是无效的。
- 不可重复读
  在整个事务过程中，每次读取同一条数据的结果都是不一样的。如果事务1在事务2的更新操作之前读取一条数据，在事务2的更新操作之后读取一次数据，那么两次读取的结果是不一样的。针对的是其他事物的update和delete
- 幻读
  在同一事物之中查询多次数据库，每次查询的结果集数量都是不一样的。针对的是其他事务的insert

## 事物的隔离级别

- 未提交读<Read Uncommitted>
  允许脏读，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。也就是可能读取到其他事务未提交但是已修改后的数据。
- 提交读<Read Committed>
  只能读取到已经提交的数据。Oracle数据库采用的是提交读级别。
- 可重复读<Repeated Read>
  无论其他事务是否修改并提交了数据，在本事务结束之前，读取到的数据值始终不受其他事务影响。
- 串行读<Serializable>
  完全串行化的读，每次读都需要获取表级共享锁，读写互相都会阻塞。

> **MySQL的InnoDB引擎默认使用可重复读**

## 索引相关

**数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树，B树索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反它会从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。**

- InnoDB
  使用B+树作为索引结构，但是InnoDB的数据文件本身就是索引文件，叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这种索引叫做“聚焦索引”。InnoDB的辅助索引的data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。InnoDB的索引实现后，不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。在Innodb中也不建议使用非单调的字段作为主键，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，建议使用自增字段作为主键。

- 四类索引

  - index
    普通索引，数据可以重复，没有限制
  - unique
    唯一索引，要求索引列的值必须唯一，但允许有空值；如果是组合索引、那么列值的组合必须唯一
  - primary key
    主键索引，是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。
    组合索引，在多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。
  - fulltext
    全文索引，是对于大表的文本域：char/varchar/text列才能创建全文索引，主要用于查找文本中的关键字，并不是与索引中的值进行比较。fulltext更像是一个搜索引擎，配合match against操作使用，而不是一般的where语句加like。

  > 全文索引目前只有MyISAM存储引擎支持全文索引，InnoDB引擎5.6以下版本还不支持全文索引

## 数据库三范式

- 确保每列都保持原子性
- 确保表中每列都和主键相关
- 确保每列都和主键列直接相关，而不能间接相关

## Myisam和InnoDB的区别

- InnoDB支持事务，MyISAM不支持。
- MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用。
- InnoDB支持外键，MyISAM不支持。
- 从MySQL5.5.5以后，InnoDB是默认引擎。
- MyISAM支持全文类型索引，而InnoDB不支持全文索引。
- InnoDB中不保存表的总行数，select count(*) from table时，InnoDB需要扫描整个表计算有多少行，但MyISAM只需简单读出保存好的总行数即可。注：当count(*)语句包含where条件时MyISAM也需扫描整个表。
- 对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。
- 清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。MyisAM使用delete语句删除后并不会立刻清理磁盘空间，需要定时清理，命令：OPTIMIZE table dept;
- InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’）
- Myisam创建表生成三个文件：.frm 数据表结构 、 .myd 数据文件 、 .myi 索引文件，Innodb只生成一个 .frm文件，数据存放在ibdata1.log
- 现在一般都选用InnoDB，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。
- 应用场景：
  - MyISAM不支持事务处理等高级功能，但它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
  - InnoDB用于需要事务处理的应用程序，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。

## 索引失效的几种情况

- 表数据。

|  id  | name | age  |   pos   |      add_time       |
| :--: | :--: | :--: | :-----: | :-----------------: |
|  1   |  z3  |  22  | manager | 2020-05-06 13:42:27 |
|  2   | July |  23  |   dev   | 2020-05-06 13:42:27 |
|  3   | Bob  |  24  |   dev   | 2020-05-06 13:42:27 |
|  4   | Tom  |  25  |   dev   | 2020-05-06 13:42:27 |
|  5   | 111  |  26  |   dev   | 2020-05-06 13:42:27 |

- id是主键，pos是单独的索引，name和age是多列索引（复合索引）
|  索引名  |    列     |
| :------: | :-------: |
| PRIMARY  |    id     |
|  O_pos   |    pos    |
| O_duolie | NAME, age |

  

### 1 查询条件存在or

- 正常情况下

  ```java
  EXPLAIN SELECT * FROM `staffs` WHERE NAME = "July";
  
  rows: 1;  // 索引生效、只查询了一条
      
  EXPLAIN SELECT * FROM `staffs` WHERE NAME = "July" AND 1 = 1;
  rows: 1; // 索引生效、只查询了一条
  ```

- 使用or

  ```java
  EXPLAIN SELECT * FROM `staffs` WHERE NAME LIKE "July" OR 1 = 1;
  rows: 5; //索引失效，扫描全表
      
  // 特殊的，如果or的所有条件都加入索引，那么也可以生效
  EXPLAIN SELECT * FROM `staffs` WHERE NAME LIKE "July" OR id = 2;
  rows: 2; //索引生效
  ```

### 2 多列索引

- 对于多列索引，如果使用的不是第一部分，那么也会失效

  ```java
  EXPLAIN SELECT * FROM `staffs` WHERE age=22;
  rows: 5; // 索引失效，扫描全表
  ```
### 3 左模糊查询

- 如果模糊查询是左模糊，那么索引也会失效。原因是MySQL采用的b-tree作为索引结构，b-tree最左前缀原则要求前缀必须是明确的，否则b-tree索引失效。

```
  EXPLAIN SELECT * FROM `staffs` WHERE NAME LIKE 'July';
  rows: 1; // 索引生效
  
  EXPLAIN SELECT * FROM `staffs` WHERE NAME LIKE '%uly';
  rows: 5; // 索引失效--左模糊
  
  EXPLAIN SELECT * FROM `staffs` WHERE NAME LIKE 'Jul%';
  rows: 1; // 索引生效--右模糊
  
  EXPLAIN SELECT * FROM `staffs` WHERE NAME LIKE '%ul%';
  rows: 5; // 索引失效--全模糊
```

### 6 字符串类型

- 如果某列（name）属性是varchar类型，即使这一列存储了一些数值类型（111），那么也一定要用引号引起来，否则索引会失效

  ```java
  EXPLAIN SELECT * FROM `staffs` WHERE name = '111';
  rows: 1; // 索引生效
  
  EXPLAIN SELECT * FROM `staffs` WHERE NAME = 111;
  rows: 5; // 索引失效
  ```

### 7 函数

- 不在索引列上做任何操作（计算、函数、类型转换）等，否则会索引失效而导致全表扫描。

  ```java
  EXPLAIN SELECT * FROM `staffs` WHERE NAME LIKE 'July';
  rows: 1; // 索引生效
  
  EXPLAIN SELECT * FROM `staffs` WHERE LEFT(NAME, 4) = 'July';
  rows: 5; // 索引失效
  ```

### 8 不等于

- mysql 会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配。范围列可以用到索引，但是范围列后面的列无法用到索引。即，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。

### 9 is null

- 使用**is null **或者**is not null**也会导致索引失效

## 数据库优化建议

### 1 少用运算

- 如果在查询条件中含有函数或者表达式，将导致索引失效而进行全表扫描

  ```java
  select * from user where YEAR(birthday) < 1990;
  
  // 可以改造成
  
  select * from users where birthday < '1990-01-01';
  ```

### 2 默认值不为NULL

- 只要列中含有NULL值、都将不会被包含在索引中，复合索引中只要一列含有NULL值，那么这一列对于此复合索引就是无效的。所以在数据库设计时不要让字段的默认值设置为NULL。

### 3 索引列选择

- 尽量选择区分度高的列作为索引。区分度公式：

  ```java
  count(distinct col) / count(*);
  ```

  表示字段不重复的比例，值越大说明不重复的数据越多，唯一索引（id）的区分度为1，而一些状态（status）、性别（sex）的值一般就俩，在大数据面前区分度就是0。一般来说join的字段要求区分度为0.1以上，也就是平均查询一条记录扫描10条记录以内。

### 4 多使用覆盖索引

- 如果一个索引包含所有需要的查询所需要的字段，则称之为覆盖索引。覆盖索引能够极大的提升性能，理想情况下，我们只需要读取索引、无需读表就可以获取结果，极大减少了数据访问量。