## 1 业务中的分布式场景

​	分布式主要是为了提供可扩展性以及高可用性，业务中使用分布式的场景主要有分布式存储以及分布式计算。

​	分布式存储中可以将数据分片到多个节点上，不仅可以提高性能（可扩展性），同时也可以使用多个节点对同一份数据进行备份。

​	至于分布式计算，就是将一个大的计算任务分解成小任务分配到多台节点上去执行，再汇总每个小任务的执行结果得到最终结果。MapReduce 是分布式计算的最好例子。

## 2 CAP

### 1.1 C (一致性)

​	Consistency。

​	对于某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。

### 1.2 A(可用性)

​	非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。

### 1.3 P(分区容错性)

​	当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。

## 3 分布式事务

> 指事务的操作位于不同的节点上，需要保证事务的ACID特性

**产生原因：**

- 数据库的分库分表
- 微服务架构 / SOA架构

**应用场景：**

- 下单时：减少库存、更新订单状态。库存和订单不在一个数据库，因此涉及到分布式事务

**解决方案：**

### 3.1 两阶段提交协议

​	两阶段提交协议可以很好得解决分布式事务问题，它可以使用 XA 来实现，XA 它包含两个部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如 Oracle、DB2 这些商业数据库都实现了 XA 接口；而事务管理器作为全局的协调者，负责各个本地资源的提交和回滚。

### 3.2 消息中间件

​	消息中间件也就是`MQ`，它本质上是一个暂存转发消息的一个中间件。在分布式应用当中，我们可以把一个业务操作转换成一个消息，比如支付宝的余额转入余额宝操作，支付宝系统执行减少余额操作之后向消息系统发送一个消息，余额宝系统订阅这条消息然后进行增加余额宝操作。

- 点对点模式

  - 消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息
  - 消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。
  - Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。

  <img src="..\cache\img\20150817113531436.jpg" style="zoom:50%;" />

- 发布订阅模式

  ​	消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。

  <img src="..\cache\img\20150817113626248.jpg" style="zoom:50%;" />

#### 3.2.1 消息处理模型

[消息队列]: ../消息队列/03经典面试题.md

## 4 负载均衡算法与实现

### 4.1 轮询

轮询算法把每个请求轮流发送到每个服务器上。该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担多大的负载。

### 4.2 加权轮询

加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。

### 4.3 最少链接

由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数多大，而另一台服务器的连接多小，造成负载不均衡。最少连接算法就是将请求发送给当前最少连接数的服务器上。

### 4.4 加权最小连接

在最小连接的基础上，根据服务器的性能为每台服务器分配权重，根据权重计算出每台服务器能处理的连接数。

### 4.5 哈希算法

使用哈希算法将IP生成一个数值类型的值，然后与当前机器的数量取模，得到的值就是该请求应该分布到的服务器编号。

## 5 分布式锁

### 5.1 定义和使用场景

​	Java 提供了两种内置的锁的实现，一种是由` JVM `实现的` synchronized`，另一种是`JDK`提供的`Lock`。当我们的应用是单机或者说单进程应用时，可以使用synchronized或者Lock实现；当应用涉及到多节点、多进程共同完成时，这时候需要一个全局的分布式锁来完成。

- 情景

  如果一个应用有手机 `APP` 端和` Web` 端，如果在两个客户端同时进行一项操作时，那么就会导致这项操作重复进行。

### 5.2 实现方式

#### 5.2.1 数据库分布式锁

- 基于MySQL锁表

  这种方式完全依靠数据库唯一索引来实现，当想要获得锁时，就向数据库中插入一条记录，释放锁时就删除这条记录。如果记录具有唯一索引，就不会同时插入同一条记录。这种方式存在以下几个问题：

  - 锁没有失效时间，解锁失败会导致死锁，其他线程无法再获得锁。
  - 只能是非阻塞锁，插入失败直接就报错了，无法重试。
  - 不可重入，同一线程在没有释放锁之前无法再获得锁。

- 采用乐观锁增加版本号

  根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败。

#### 5.2.2 Redis分布式锁

- 基于SetNx，Expire

  ​	使用 SETNX（set if not exist）命令插入一个键值对时，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。因此客户端在尝试获得锁时，先使用 SETNX 向 Redis 中插入一个记录，如果返回 True 表示获得锁，返回 False 表示已经有客户端占用锁。

  ​	EXPIRE 可以为一个键值对设置一个过期时间，从而避免了死锁的发生。

- 基于RedLock算法

  > ReadLock 算法使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时还可用。

  - 尝试从 N 个相互独立 Redis 实例获取锁，如果一个实例不可用，应该尽快尝试下一个。
  - 计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N/2+1）实例上获取了锁，那么就认为锁获取成功了。
  - 如果锁获取失败，会到每个实例上释放锁。

## 6 分布式Session

​	如果我们的服务再多台服务器上部署多个实例，并且没有处理Session的共享，那么可能会出现用户频繁的登录现象。用户在第一次访问网站时，Nginx 通过其负载均衡机制将用户请求转发到 A 服务器，这时 A 服务器就会给用户创建一个 Session。当用户第二次发送请求时，Nginx 将其负载均衡到 B 服务器，而这时候 B 服务器并不存在 Session，所以就会将用户踢到登录页面。这将大大降低用户体验度，导致用户的流失，这种情况是项目绝不应该出现的。

### 6.1 粘性Session

​	粘性Session是使用hash算法或者其他合适的算法将用户锁定到某一台服务器上，使得某个IP的所有请求全部打在同一台服务器上，这就相当于把某个用户和某台服务器粘在了一起，这就是粘性Session。

- **优点：**

  简单、容易实现，不需要对Session做任何处理。

- **缺点：**

  缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二台服务器上时，他的Session信息都会失效。

- **适用场景：**
  - 发生故障对客户产生的影响较小
  - 服务器发生故障时低概率事件

### 6.2 服务器 Session 复制

- **原理：**

  ​	任何一个服务器上的 Session 发生改变，该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 Session，以此来保证 Session 同步。

- **优点：**

  可容错，各个服务器间 Session 能够实时响应。

- **缺点：**

  会对网络负荷造成一定压力，如果 Session 量大的话可能会造成网络堵塞，拖慢服务器性能。

- **实现方式：**

  - 设置 Tomcat 的 server.xml 开启 tomcat 集群功能。
  - 在应用里增加信息：通知应用当前处于集群环境中，支持分布式，即在 web.xml 中添加<distributable/> 选项。

### 6.3 Session共享机制

> 使用分布式缓存方案比如 Memcached、Redis，但是要求 Memcached 或 Redis 必须是集群，以此来保证Session的安全存储。

使用 Session 共享也分两种机制，两种情况如下：

- 粘性Session共享机制

  和粘性 Session 一样，一个用户的 Session 会绑定到一个 Tomcat 上。Memcached 只是起到备份作用。

- 非粘性Session共享机制

  Tomcat 本身不存储 Session，而是存入 Redis或者Memcached 中。（主从）

  - 优点

    可容错，Session实时响应

  - 实现方式

    用开源的 msm 插件解决 Tomcat 之间的 Session 共享：Memcached_Session_Manager（MSM）

    <img src="..\cache\img\16261148dcc7f70f.jpg" style="zoom:70%;" />

### 6.4 Session持久化数据库

拿出一个数据库、单独存储Session信息，保证Session的持久化

- **优点：**

  服务器出现问题，Session 不会丢失

- **缺点：**

  如果网站的访问量很大，把 Session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。

### 6.5 Terracotta 实现 Session 复制

​	`Terracotta` [.terə'kɑtə] 的基本原理是对于集群间共享的数据，当在一个节点发生变化的时候，Terracotta 只把变化的部分发送给 Terracotta 服务器，然后由服务器把它转发给真正需要这个数据的节点。它是服务器 Session 复制的优化。

- 优点：

  这样对网络的压力就非常小，各个节点也不必浪费 CPU 时间和内存进行大量的序列化操作。把这种集群间数据共享的机制应用在 Session 同步上，既避免了对数据库的依赖，又能达到负载均衡和灾难恢复的效果。

## 7 分库分表的问题

- 事务问题

  使用分布式事务

- 查询问题

  使用汇总表

- ID唯一

  - 使用全局唯一ID：GUID
  - 为每个分片指定一个ID范围

