## ACID特性

- **原子性（Atomicity）**

  一个事务中所有操作，要么全部成功、要么全部失败，不会结束在中间某个环节。

  事务在执行过程中发生错误，会被回滚到事务之前的状态，就像这个事务从来没有执行过一样。

- **一致性(Consistency)**

  在一个事务执行之前和之后、数据库都必须处于一致性的状态。

  如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

- **隔离性(Isolation)**

  在并发环境中，当不同的事务同时操作相同的数据时，每个事务都有各自完整的数据空间，每个事务所做的修改必须与任何其他事务所做的修改隔离。一个事务查看数据更新时，数据所处的状态要么是另一个事务修改它之前的状态，要么是另一个事务修改它之后的状态，事务不会查看到中间状态的数据。

- **持久性(Durability)**

  事务只要成功结束，它对数据所做的更新就必须永久保存下来。即使发生数据库服务崩溃，重新启动数据库服务后，数据库还能恢复到数据成功结束时的状态。

## InnoDB原理

### 原子性

#### 回滚日志

​	想要保证事务的原子性，就需要在发生异常时，对已经执行的操作进行**回滚**，而在<code style='color:#c7254e'>MySQL</code>中，恢复机制是通过回滚日志（<code style='color:#c7254e'>undo log</code>）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。

​	**回滚日志**除了能够在发生错误或者用户执行<code style='color:#c7254e'>Rollback</code>时提供回滚相关信息，他还能够在系统发生崩溃、数据库进程直接被杀死之后，当用户再次启动数据库进程时、还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化的操作。

​	**回滚日志**并不能将数据库物理地恢复到执行语句或者事务之前的样子；他是逻辑日志，当回滚日志被使用时，他只会按照日志逻辑地将数据库中的修改撤销掉，可以理解为：我们在事务中使用的每一条<code style='color:#c7254e'>insert</code>语句都对应了一条<code style='color:#c7254e'>delete</code>，每一条<code style='color:#c7254e'>update</code>也对应了一条相反的<code style='color:#c7254e'>update</code>。

### 持久性

​	与**原子性**一样，事务的**持久性**也是通过**日志**来实现的，<code style='color:#c7254e'>MySQL</code>使用重做日志（<code style='color:#c7254e'>redo log</code>）实现事务的持久性。**重做日志**分为两部分，一是内存中的重做日志缓冲区，因为重做日志缓存区在内容中，所以它是容易丢失的；另一个是在磁盘上的重做日志文件，它是持久的。

​	当我们在一个事务中尝试对数据进行修改时，它会先将数据从磁盘读入内存，并更新内存中的缓存数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，<code style='color:#c7254e'>MySQL</code>会将重做日志缓存中的内容刷新到重做日志文件中，再将内存中的数据更新到磁盘中。

### 隔离性

是通过数据库锁实现的。

### 一致性

是通过undo log实现的。

## 分布式事务

### 一致性

- **强一致性**

  任何一次读都能读到某个数据的最近一次写的数据。系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。简言之，在任意时刻，所有节点中的数据是一样的。

- **弱一致性**

  数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。

- **最终一致性**

  不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。简单说，就是在一段时间后，节点间的数据会最终达到一致状态。

### CAP原则

- 一致性（`Consistency`）

  在分布式系统的所有数据备份，在同一时刻是否具有相同的值。（等同于所有节点访问同一份最新的数据副本）。

- 可用性（`Availability`）

  在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求（对数据更新具备高可用性）。

- 分区容错性（`Partition tolerance`）

  以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

​	`CAP` 原则的精髓就是要么 `AP`，要么` CP`，要么 `AC`，但是不存在 `CAP`。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时` C `和` P `两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了` CP` 系统，但是` CAP` 不可同时满足。

### BASE理论

> `BASE` 理论指的是基本可用 `Basically` `Available`，软状态` Soft State`，最终一致性` Eventual` `Consistency`，核心思想是即便无法做到强一致性，但应该采用适合的方式保证最终一致性。

- BA：`Basically Available `基本可用，分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。
- S：`Soft State` 软状态，允许系统存在中间状态，而该中间状态不会影响系统整体可用性。
- E：`Consistency` 最终一致性，系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。
  BASE 理论本质上是对 CAP 理论的延伸，是对 CAP 中 AP 方案的一个补充。

**柔性事务**

不同于 `ACID` 的刚性事务，在分布式场景下基于 `BASE `理论，就出现了柔性事务的概念。要想通过柔性事务来达到最终的一致性，就需要依赖于一些特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样；但是都不满足的话，是不可能做柔性事务的。

不同于` ACID `的刚性事务，在分布式场景下基于` BASE` 理论，就出现了柔性事务的概念。要想通过柔性事务来达到最终的一致性，就需要依赖于一些特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样；但是都不满足的话，是不可能做柔性事务的。

**幂等事务**

在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，支付流程中第三方支付系统告知系统中某个订单支付成功，接收该支付回调接口在网络正常的情况下无论操作多少次都应该返回成功。

### 使用场景

在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，支付流程中第三方支付系统告知系统中某个订单支付成功，接收该支付回调接口在网络正常的情况下无论操作多少次都应该返回成功。

**转账**

转账是最经典那的分布式事务场景，假设用户 A 使用银行 app 发起一笔跨行转账给用户 B，银行系统首先扣掉用户 A 的钱，然后增加用户 B 账户中的余额。此时就会出现 2 种异常情况：1. 用户 A 的账户扣款成功，用户 B 账户余额增加失败 2. 用户 A 账户扣款失败，用户 B 账户余额增加成功。对于银行系统来说，以上 2 种情况都是不允许发生，此时就需要分布式事务来保证转账操作的成功。

**下单扣库存**

在电商系统中，下单是用户最常见操作。在下单接口中必定会涉及生成订单 id, 扣减库存等操作，对于微服务架构系统，订单 id 与库存服务一般都是独立的服务，此时就需要分布式事务来保证整个下单接口的成功。

**同步超时**

继续以电商系统为例，在微服务体系架构下，我们的支付与订单都是作为单独的系统存在。订单的支付状态依赖支付系统的通知，假设一个场景：我们的支付系统收到来自第三方支付的通知，告知某个订单支付成功，接收通知接口需要同步调用订单服务变更订单状态接口，更新订单状态为成功。流程图如下，从图中可以看出有两次调用，第三方支付调用支付服务，以及支付服务调用订单服务，这两步调用都可能出现调用超时的情况，此处如果没有分布式事务的保证，就会出现用户订单实际支付情况与最终用户看到的订单支付情况不一致的情况。

![](..\cache\img\notify-message.png)

## 解决方案

### 两阶段提交/XA

​	两阶段提交，顾名思义就是要分两步提交。存在一个负责协调各个本地资源管理器的事务管理器，本地资源管理器一般是由数据库实现，事务管理器在第一阶段的时候询问各个资源管理器是否都就绪？如果收到每个资源的回复都是 yes，则在第二阶段提交事务，如果其中任意一个资源的回复是 no, 则回滚事务。

<img src="..\cache\img\XA-first.jpg" style="zoom:50%;" />

![](..\cache\img\XA-second.jpg)

**大致的流程：**

第一阶段（prepare）：事务管理器向所有本地资源管理器发起请求，询问是否是 ready 状态，所有参与者都将本事务能否成功的信息反馈发给协调者；
第二阶段 (commit/rollback)：事务管理器根据所有本地资源管理器的反馈，通知所有本地资源管理器，步调一致地在所有分支上提交或者回滚。

**存在的问题：**

- 同步阻塞：当参与事务者存在占用公共资源的情况，其中一个占用了资源，其他事务参与者就只能阻塞等待资源释放，处于阻塞状态。

- 单点故障：一旦事务管理器出现故障，整个系统不可用。
- 数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
- 不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。

### TCC

**TCC(Try Confirm Cancel)**

**try**

尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）

**confirm**

确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。

**cancel**

取消执行，释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。

> 在 Try 阶段，是对业务系统进行检查及资源预览，比如订单和存储操作，需要检查库存剩余数量是否够用，并进行预留，预留操作的话就是新建一个可用库存数量字段，Try 阶段操作是对这个可用库存数量进行操作。
>
> 基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高。

TCC事务机制相比于XA，解决了其中几个缺点：

- 解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。
- 同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。
- 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性

### 本地消息表

<img src="..\cache\img\native-message.jpg" style="zoom: 50%;" />

1. 当系统 A 被其他系统调用发生数据库表更操作，首先会更新数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中
2. 系统 A 的脚本定期轮询本地消息往 mq 中写入一条消息，如果消息发送失败会进行重试
3. 系统 B 消费 mq 中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费 mq 中的消息进行重试，如果业务上的失败，可以通知系统 A 进行回滚操作

**本地消息表实现的条件：**

1. 消费者与生成者的接口都要支持幂等
2. 生产者需要额外的创建消息表
3. 需要提供补偿逻辑，如果消费者业务失败，需要生产者支持回滚操作

**容错机制：**

1. 步骤 1 失败时，事务直接回滚
2. 步骤 2、3 写 mq 与消费 mq 失败会进行重试
3. 步骤 3 业务失败系统 B 向系统 A 发起事务回滚操作

