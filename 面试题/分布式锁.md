## 5 分布式锁

### 5.1 定义和使用场景

​	Java 提供了两种内置的锁的实现，一种是由` JVM `实现的` synchronized`，另一种是`JDK`提供的`Lock`。当我们的应用是单机或者说单进程应用时，可以使用synchronized或者Lock实现；当应用涉及到多节点、多进程共同完成时，这时候需要一个全局的分布式锁来完成。

- 情景

  如果一个应用有手机 `APP` 端和` Web` 端，如果在两个客户端同时进行一项操作时，那么就会导致这项操作重复进行。

### 5.2 实现方式

#### 5.2.1 数据库分布式锁

- 基于MySQL锁表

  这种方式完全依靠数据库唯一索引来实现，当想要获得锁时，就向数据库中插入一条记录，释放锁时就删除这条记录。如果记录具有唯一索引，就不会同时插入同一条记录。这种方式存在以下几个问题：

  - 锁没有失效时间，解锁失败会导致死锁，其他线程无法再获得锁。
  - 只能是非阻塞锁，插入失败直接就报错了，无法重试。
  - 不可重入，同一线程在没有释放锁之前无法再获得锁。

- 采用乐观锁增加版本号

  根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败。

#### 5.2.2 Redis分布式锁

- 基于SetNx，Expire

  ​	使用 SETNX（set if not exist）命令插入一个键值对时，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。因此客户端在尝试获得锁时，先使用 SETNX 向 Redis 中插入一个记录，如果返回 True 表示获得锁，返回 False 表示已经有客户端占用锁。

  ​	EXPIRE 可以为一个键值对设置一个过期时间，从而避免了死锁的发生。

- 基于RedLock算法

  > ReadLock 算法使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时还可用。

  - 尝试从 N 个相互独立 Redis 实例获取锁，如果一个实例不可用，应该尽快尝试下一个。
  - 计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N/2+1）实例上获取了锁，那么就认为锁获取成功了。
  - 如果锁获取失败，会到每个实例上释放锁。