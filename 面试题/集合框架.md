## 1 HashMap

### 1.1 初始大小

​	HashMap默认的初始大小为16，可以根据业务需求赋值一个初始值，尽量避免扩容操作；

### 1.2 装载因子和动态扩容

​	装载因子默认是0.75，当HashMap中元素个数超过散列表容量*0.75之后，就会启动扩容操作，每次都会扩展为原来的2倍大小。

### 1.3 散列冲突解决方法

​	HashMap采用链表法解决Hash冲突。在JDK1.8版本中，引入红黑树，当链表长度大于8时，链表转换为红黑树。这时候利用红黑树快速增删改擦汗的特性、提高HashMap的性能。当红黑树节点个数少于8时，又会将红黑树转换为链表。因为在数据量较小的情况下，红黑树需要维护平衡，比起链表来性能并没有明显的优势。

**其他算法**

- 开放寻址法

  当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

  在散列表中查找数据的过程和插入操作有点类似，我们通过散列函数计算出要查找的元素的键值对应的散列值，然后比较散列表中下标为散列值的元素和要查找的元素是否相同，如果相同该元素就是我们要查找的元素，否则就顺序往后查找。如果遍历完数组、没有找到相同的值，则说明该值不在散列表中。

  这种算法就是线性探测法，他有很大的弊端，当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。

  - 二次探测

    线性探测法每次探测的步长为1，比如hash(key)+1、hash(key)+2。而二次探测法每次步长为线性探测的二次方，比如hash(key)+1、hash(key)+4...

  - 双重探测

    双重探测就是我们先用第一个散列函数进行探测，如果还没找到空闲位置，那么就换第二种探测算法。

  - **LinkedHashMap**

    **LinkedHashMap**采用开放寻址法来解决hash冲突。开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。

    用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。

  

